const express = require('express');
const line = require('@line/bot-sdk');
const axios = require('axios');
const crypto = require('crypto');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const twilio = require('twilio'); // Added for Twilio integration

const app = express();
const PORT = process.env.PORT || 3000;

// Ë®≠ÂÆöÊôÇÂçÄÁÇ∫Âè∞ÁÅ£
process.env.TZ = 'Asia/Taipei';

console.log('üöÄ Ê≠£Âú®ÂïüÂãïÂ¢ûÂº∑Áâà LINE Bot v11.0...');
console.log('‚è∞ Áï∂ÂâçÊôÇÈñì:', new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' }));

// ÈÖçÁΩÆË≥áË®ä
const config = {
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN || 'G5/Jatw/Mm7gpHjRnVG89Mxp+6QWXINk4mGkga8o3g9TRa96NXiOed5ylkNZjuUtGHXFKCV46xX1t73PZkYdjlqIFoJHe0XiPUP4EyRy/jwJ6sqRtXivrQNA0WH+DK9pLUKg/ybSZ1mvGywuK8upBAdB04t89/1O/w1cDnyilFU=',
  channelSecret: process.env.LINE_CHANNEL_SECRET || 'ff89f01585f2b68301b8f8911174cd87'
};

// API Keys
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || 'AIzaSyBWCitsjkm7DPe_aREubKIZjqmgXafVKNE';
const BACKUP_AI_KEY = process.env.BACKUP_AI_KEY || 'sk-U8sgp8YW0jX3flzFCM1azu85GS6WbHlMyqU7L0ZDer9n8aUM';
const BACKUP_AI_URL = process.env.BACKUP_AI_URL || 'https://api.chatanywhere.org/v1';
const NEWS_API_KEY = process.env.NEWS_API_KEY || '5807e3e70bd2424584afdfc6e932108b';
const TMDB_API_KEY = process.env.TMDB_API_KEY || 'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyMzI4YmU1YzdhNDA1OTczZDdjMjA0NDlkYmVkOTg4OCIsIm5iZiI6MS43NDYwNzg5MDI5MTgwMDAyZSs5LCJzdWIiOiI2ODEzMGNiNjgyODI5Y2NhNzExZmJkNDkiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.FQlIdfWlf4E0Tw9sYRF7txbWymAby77KnHjTVNFSpdM';
const WEATHER_API_KEY = process.env.WEATHER_API_KEY || 'CWA-C80C73F3-7042-4D8D-A88A-D39DD2CFF841';

// Twilio Configuration
const TWILIO_ACCOUNT_SID = process.env.TWILIO_ACCOUNT_SID || 'YOUR_TWILIO_ACCOUNT_SID_PLACEHOLDER';
const TWILIO_AUTH_TOKEN = process.env.TWILIO_AUTH_TOKEN || 'YOUR_TWILIO_AUTH_TOKEN_PLACEHOLDER';
const TWILIO_PHONE_NUMBER = process.env.TWILIO_PHONE_NUMBER || 'YOUR_TWILIO_PHONE_NUMBER_PLACEHOLDER'; // Your Twilio phone number
const OWNER_PHONE_NUMBER = process.env.OWNER_PHONE_NUMBER || 'OWNER_PHONE_NUMBER_TO_CALL_PLACEHOLDER';   // Recipient's phone number (E.164 format)

let twilioClient = null;
if (TWILIO_ACCOUNT_SID !== 'YOUR_TWILIO_ACCOUNT_SID_PLACEHOLDER' && 
    TWILIO_AUTH_TOKEN !== 'YOUR_TWILIO_AUTH_TOKEN_PLACEHOLDER' &&
    TWILIO_PHONE_NUMBER !== 'YOUR_TWILIO_PHONE_NUMBER_PLACEHOLDER' &&
    OWNER_PHONE_NUMBER !== 'OWNER_PHONE_NUMBER_TO_CALL_PLACEHOLDER') {
  try {
    twilioClient = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);
    console.log('üìû Twilio client initialized successfully.');
  } catch (error) {
    console.error('üìû Twilio client initialization failed:', error.message);
    twilioClient = null;
  }
} else {
  console.log('üìû Twilio credentials not fully configured (SID, Token, Twilio Phone, or Owner Phone missing/placeholders). Twilio client not initialized.');
  twilioClient = null;
}

// Áî®Êà∂ÈÖçÁΩÆ
const OWNER_LINE_ID = 'U59af77e69411ffb99a49f1f2c3e2afc4';
const MAX_MESSAGE_LENGTH = 2000;

// ÂàùÂßãÂåñ LINE ÂÆ¢Êà∂Á´Ø
const client = new line.Client(config);
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

console.log('üîë Ê©üÂô®‰∫∫‰∏ª‰∫∫:', OWNER_LINE_ID);
console.log('‚ú® Â¢ûÂº∑ÁâàÂäüËÉΩÂ∑≤ÂïüÁî®');

// Â¢ûÂº∑ÁâàÊô∫ËÉΩAIÁ≥ªÁµ±
class EnhancedAISystem {
  constructor() {
    this.conversations = new Map();
    this.userProfiles = new Map();
    this.groupContexts = new Map(); // ÂÑ≤Â≠òÁæ§ÁµÑÂ∞çË©±‰∏ä‰∏ãÊñá
    console.log('üß† [AI_SYSTEM] EnhancedAISystem initialized.');
  }

  async generateReply(userId, message, context = {}) {
    try {
      this.recordConversation(userId, message, context);
      
      const userProfile = this.userProfiles.get(userId) || { 
        name: 'ÊúãÂèã', 
        messageCount: 0,
        isGroup: context.isGroup 
      };

      const reply = await this.generatePersonalizedReply(message, userProfile, context);
      return reply;

    } catch (error) {
      console.error('üß† [AI_SYSTEM] AI Reply generation failed:', error);
      return this.getOfflineReply(message);
    }
  }

  async generatePersonalizedReply(message, userProfile, context) {
    try {
      const model = genAI.getGenerativeModel({ 
        model: "gemini-1.5-flash-002", 
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 1000,
        }
      });
      
      const prompt = `‰Ω†ÊòØÈ°ßÊôâÁëãÔºåÈùúÂÆúÂ§ßÂ≠∏Ë≥áÁÆ°Á≥ªÂ≠∏Áîü„ÄÇÁèæÂú®Ë¶ÅÂõûË¶ÜÁî®Êà∂„ÄÇ

Áî®Êà∂Ë™™Ôºö${message}
Â∞çË©±Áí∞Â¢ÉÔºö${context.isGroup ? 'Áæ§ÁµÑÂ∞çË©±' : 'ÁßÅ‰∫∫Â∞çË©±'}

ÂõûË¶ÜÂéüÂâáÔºö
1. Â¶ÇÊûúÊòØÁæ§ÁµÑÂ∞çË©±Ôºå‰∏çË¶ÅÈÄèÈú≤ÂÄã‰∫∫Èö±ÁßÅ
2. ‰øùÊåÅÂèãÂñÑ„ÄÅÊúâË∂£ÁöÑË™ûÊ∞£
3. ÂèØ‰ª•‰ΩøÁî®Âè∞ÁÅ£Âè£Ë™ûÂ¶Ç„ÄåÂ•Ωder„Äç„ÄÅ„ÄåÂìéÂë¶„ÄçÁ≠â
4. ÂõûË¶ÜÈï∑Â∫¶ÊéßÂà∂Âú®100Â≠óÂÖß

Ë´ãËá™ÁÑ∂ÂõûË¶ÜÔºö`;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      let text = response.text().replace(/[*#`_~]/g, '').trim();
      
      return text || this.getOfflineReply(message);
      
    } catch (error) {
      console.log('üß† [AI_SYSTEM] Gemini failed, attempting backup AI. Error:', error.message);
      return await this.useBackupAI(message, context);
    }
  }

  async useBackupAI(message, context) {
    try {
      const response = await axios.post(`${BACKUP_AI_URL}/chat/completions`, {
        model: 'gpt-3.5-turbo',
        messages: [{ 
          role: 'user', 
          content: `‰ª•È°ßÊôâÁëãÁöÑË∫´‰ªΩÂõûË¶ÜÔºö${message}Ôºà${context.isGroup ? 'Áæ§ÁµÑ' : 'ÁßÅ‰∫∫'}Â∞çË©±Ôºâ` 
        }],
        max_tokens: 200,
        temperature: 0.7
      }, {
        headers: {
          'Authorization': `Bearer ${BACKUP_AI_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 10000
      });

      return response.data.choices[0].message.content.trim();
      
    } catch (error) {
      console.error('üß† [AI_SYSTEM] Backup AI also failed:', error.message);
      return this.getOfflineReply(message);
    }
  }

  getOfflineReply(message) {
    if (message.includes('‰Ω†Â•Ω') || message.includes('Âó®')) {
      return 'Âó®ÔºÅÊàëÊòØÈ°ßÊôâÁëãÁöÑAIÂä©ÊâãÔºåÂæàÈ´òËààË¶ãÂà∞‰Ω†ÔºÅüòä';
    }
    if (message.includes('Ë¨ùË¨ù') || message.includes('ÊÑüË¨ù')) {
      return '‰∏çÂÆ¢Ê∞£Âï¶ÔºÅÊàëÂæàÊ®ÇÊÑèÂπ´ÂøôÔΩû';
    }
    if (message.includes('ÂÜçË¶ã') || message.includes('Êé∞Êé∞')) {
      return 'Êé∞Êé∞ÔΩûÊúâ‰∫ãÈö®ÊôÇÊâæÊàëÔºÅ';
    }
    
    const offlineResponses = [
      '‰Ω†Ë™™ÂæóÂæàÊúâÈÅìÁêÜÂë¢ÔºÅÊàë‰πüÊòØÈÄôÊ®£ÊÉ≥ÁöÑÔΩû',
      'ÈÄôÂÄãË©±È°åÂæàÊúâË∂£ÔºåËÆìÊàëÂ≠∏Âà∞‰∫ÜÊñ∞Êù±Ë•øÔºÅ',
      'ÂìàÂìàÔºå‰Ω†ÈÄôÊ®£Ë™™ÊàëË¶∫ÂæóÂæàÊúâÊÑèÊÄùÔΩû',
      'ÊàëÊáÇÊàëÊáÇÔºåÊúâÊôÇÂÄôÂ∞±ÊòØÊúÉÈÄôÊ®£Â∞çÂêßÔºÅ',
      'Ë™™ÂæóÂ•ΩÔºÅÊàëÂÆåÂÖ®ÂêåÊÑè‰Ω†ÁöÑÁúãÊ≥ïÔΩû'
    ];
    
    const randomIndex = Math.floor(Math.random() * offlineResponses.length);
    return offlineResponses[randomIndex];
  }

  recordConversation(userId, message, context) {
    const convId = `conv-${Date.now()}`;
    this.conversations.set(convId, {
      userId,
      message,
      timestamp: new Date(),
      isGroup: context.isGroup,
      groupId: context.groupId
    });

    if (context.isGroup && context.groupId) {
      if (!this.groupContexts.has(context.groupId)) {
        this.groupContexts.set(context.groupId, []);
      }
      const groupContext = this.groupContexts.get(context.groupId);
      groupContext.push({
        userId,
        userName: context.userName,
        message,
        timestamp: new Date()
      });
      if (groupContext.length > 20) {
        groupContext.shift();
      }
    }

    if (!this.userProfiles.has(userId)) {
      this.userProfiles.set(userId, {
        name: context.userName || 'ÊúãÂèã',
        messageCount: 0,
        isGroup: context.isGroup,
        lastSeen: new Date()
      });
    }
    
    const profile = this.userProfiles.get(userId);
    profile.messageCount++;
    profile.lastSeen = new Date();

    if (this.conversations.size > 1000) { 
      const oldestKey = this.conversations.keys().next().value;
      this.conversations.delete(oldestKey);
    }
  }

  getGroupContext(groupId, lines = 10) {
    const context = this.groupContexts.get(groupId) || [];
    const recent = context.slice(-lines);
    return recent.map(msg => 
      `${msg.userName || 'Êú™Áü•Áî®Êà∂'}: ${msg.message}`
    ).join('\n');
  }
}

// Â¢ûÂº∑ÁâàÊ±∫Á≠ñÁ≥ªÁµ±
class EnhancedDecisionSystem {
  constructor() {
    this.pendingDecisions = new Map();
    this.decisionContexts = new Map(); 
    console.log('‚öñÔ∏è [DECISION_SYSTEM] EnhancedDecisionSystem initialized.');
  }

  shouldAskOwner(message, context) {
    const socialKeywords = ['Á¥Ñ', 'ÈÇÄË´ã', 'ËÅöÊúÉ', 'ÂêÉÈ£Ø', 'ÂñùËå∂', 'Ë¶ãÈù¢', 'ÂèÉÂä†', 'Âá∫Âéª', 'ËÅöÈ§ê'];
    const moneyKeywords = ['ÂÄü', 'Èå¢', '‰ªòÊ¨æ', 'Ë≤ªÁî®', 'Ë≤∑', 'Ë≥£', 'ËΩâÂ∏≥', 'ÂåØÊ¨æ'];
    const importantKeywords = ['ÈáçË¶Å', 'Á∑äÊÄ•', 'Âπ´Âøô', 'ÊãúË®ó', 'Ë´ãÂïè'];
    
    const hasSocialKeyword = socialKeywords.some(keyword => message.includes(keyword));
    const hasMoneyKeyword = moneyKeywords.some(keyword => message.includes(keyword));
    const hasImportantKeyword = importantKeywords.some(keyword => message.includes(keyword));
    const isGroupImportant = context.isGroup && (message.includes('All') || message.includes('@'));

    return hasSocialKeyword || hasMoneyKeyword || hasImportantKeyword || isGroupImportant;
  }

  async requestDecision(message, userId, userName, context, replyToken) {
    const decisionId = `decision-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    console.log(`‚öñÔ∏è [DECISION_SYSTEM] Requesting decision. ID: ${decisionId}, User: ${userName}(${userId}), Msg: "${message.substring(0,50)}..."`);
    
    const decision = {
      id: decisionId,
      message,
      userId,
      userName,
      context,
      timestamp: new Date(),
      replyToken,
      sourceType: context.isGroup ? 'group' : 'private',
      sourceId: context.groupId || userId
    };

    this.pendingDecisions.set(decisionId, decision);
    this.decisionContexts.set(decisionId, {
      sourceType: decision.sourceType,
      sourceId: decision.sourceId,
      userName: userName,
      groupName: context.groupName || 'ÁßÅ‰∫∫Â∞çË©±'
    });

    try {
      let contextInfo = '';
      if (context.isGroup && context.groupId && enhancedAI.groupContexts.has(context.groupId)) {
        contextInfo = enhancedAI.getGroupContext(context.groupId);
        console.log(`‚öñÔ∏è [DECISION_SYSTEM] Fetched group context for decision ${decisionId}`);
      }

      const decisionText = `ü§î ÈúÄË¶Å‰Ω†ÁöÑÊ±∫Á≠ñ [${decisionId.substr(-6)}]

üë§ ‰æÜËá™Ôºö${userName}
üìç ‰ΩçÁΩÆÔºö${context.isGroup ? `Áæ§ÁµÑ - ${context.groupName || 'Êú™Áü•Áæ§ÁµÑ'}` : 'ÁßÅ‰∫∫Â∞çË©±'}
üí¨ Ë®äÊÅØÔºö${message}

${contextInfo ? `\nüìù ÊúÄËøëÂ∞çË©±Á¥ÄÈåÑÔºö\n${contextInfo}\n` : ''}

Ë´ãÂõûË¶Ü‰Ω†ÁöÑÊ±∫ÂÆöÔºåÊàñËº∏ÂÖ•„Äå? <ID>„ÄçÊü•ÁúãÁâπÂÆöÊ±∫Á≠ñÁöÑÊõ¥Â§öÂ∞çË©±Á¥ÄÈåÑ
Ê±∫Á≠ñIDÔºö${decisionId.substr(-6)}`;

      await safePushMessage(OWNER_LINE_ID, decisionText);
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Decision request ${decisionId} sent to owner.`);
      return 'ËÆìÊàëÊÉ≥ÊÉ≥ÈÄôÂÄãË´ãÊ±ÇÔºåÁ®çÂæåÂõûË¶Ü‰Ω†ÔΩû';
      
    } catch (error) {
      console.error(`‚öñÔ∏è [DECISION_SYSTEM] Decision request ${decisionId} failed to send:`, error);
      return 'ÊàëÈúÄË¶ÅÊÉ≥ÊÉ≥ÔºåÁ®çÂæåÂõûË¶Ü‰Ω†ÔΩû';
    }
  }

  async processOwnerDecision(message, ownerId) {
    console.log(`‚öñÔ∏è [DECISION_SYSTEM] processOwnerDecision called with message: "${message}"`);
    const contextQueryMatch = message.match(/^(?:\?|more info|context)\s*([a-z0-9]{6})$/i);
    let decisionIdForContext = null;

    if (contextQueryMatch) {
      decisionIdForContext = contextQueryMatch[1];
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Context query detected for decision ID (short): ${decisionIdForContext}`);
    } else if (message === '?') {
      const pending = Array.from(this.pendingDecisions.values())
        .filter(d => new Date() - d.timestamp < 3600000); 

      if (pending.length === 0) {
        console.log(`‚öñÔ∏è [DECISION_SYSTEM] No pending decisions for '?' query.`);
        return 'ÁõÆÂâçÊ≤íÊúâÂæÖËôïÁêÜÁöÑÊ±∫Á≠ñ';
      }
      if (pending.length === 1) {
        decisionIdForContext = pending[0].id.substr(-6);
        console.log(`‚öñÔ∏è [DECISION_SYSTEM] Single pending decision, getting context for ID (short): ${decisionIdForContext}`);
      } else {
        let info = 'üìã ÂæÖËôïÁêÜÊ±∫Á≠ñÂàóË°®Ôºö\n\n';
        pending.forEach(d => {
          info += `ID: ${d.id.substr(-6)}\n`;
          info += `‰æÜËá™: ${d.userName}\n`;
          info += `Ë®äÊÅØ: ${d.message.substring(0,30)}...\n\n`;
        });
        info += 'Ë´ãËº∏ÂÖ• "? <ID>" Êàñ "context <ID>" Áç≤ÂèñÁâπÂÆöÊ±∫Á≠ñÁöÑÊõ¥Â§öË≥áË®ä„ÄÇ';
        console.log(`‚öñÔ∏è [DECISION_SYSTEM] Multiple pending decisions listed for '?' query.`);
        return info;
      }
    }

    if (decisionIdForContext) {
      let foundDecision = null;
      for (const [id, d] of this.pendingDecisions) {
        if (id.endsWith(decisionIdForContext)) {
          foundDecision = d;
          break;
        }
      }

      if (!foundDecision) {
        console.log(`‚öñÔ∏è [DECISION_SYSTEM] Decision ID (short) ${decisionIdForContext} not found for context query.`);
        return `Êâæ‰∏çÂà∞IDÁÇ∫ ${decisionIdForContext} ÁöÑÊ±∫Á≠ñË´ãÊ±Ç„ÄÇ`;
      }
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Found decision for context query: ${foundDecision.id}`);

      let contextMessageText = '';
      if (foundDecision.context.isGroup && foundDecision.context.groupId) {
        const groupHistory = enhancedAI.getGroupContext(foundDecision.context.groupId, 20);
        contextMessageText = groupHistory ? `üìù Áæ§ÁµÑÂ∞çË©±Á¥ÄÈåÑ (ÊúÄÂæå20Ââá)Ôºö\n${groupHistory}` : 'Ê≠§Áæ§ÁµÑÁõÆÂâçÊ≤íÊúâÊõ¥Â§öÂ∞çË©±Á¥ÄÈåÑÂèØ‰æõÈ°ØÁ§∫„ÄÇ';
      } else {
        contextMessageText = 'Ê≠§ÁÇ∫ÁßÅ‰∫∫Â∞çË©±ÔºåÁÑ°Ëá™ÂãïÁæ§ÁµÑÂ∞çË©±Á¥ÄÈåÑÂèØÈ°ØÁ§∫„ÄÇ';
      }
      
      const fullMessageToOwner = `üìñ ID [${decisionIdForContext}] ÁöÑË©≥Á¥∞Ë≥áË®äÔºö
üë§ ‰æÜËá™Ôºö${foundDecision.userName}
üí¨ ÂéüÂßãË®äÊÅØÔºö${foundDecision.message}

${contextMessageText}

üëâ Ë´ãÈáùÂ∞çID [${decisionIdForContext}] ÂõûË¶ÜÊÇ®ÁöÑÊ±∫ÂÆöÔºöÂêåÊÑè„ÄÅÊãíÁµïÔºåÊàñ„ÄåÂõûË¶ÜÔºö[ÊÇ®ÁöÑË®äÊÅØ]„Äç`;
      
      await safePushMessage(OWNER_LINE_ID, fullMessageToOwner);
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Sent context for decision ${foundDecision.id} to owner.`);
      return null; 
    }

    const actionIdMatch = message.match(/([a-z0-9]{6})/i);
    let targetDecisionId = null;
    let decision = null;

    if (actionIdMatch) {
      const shortId = actionIdMatch[1];
      for (const [id, d] of this.pendingDecisions) {
        if (id.endsWith(shortId)) {
          targetDecisionId = id;
          decision = d;
          break;
        }
      }
      if(decision) console.log(`‚öñÔ∏è [DECISION_SYSTEM] Action targeted at decision ID (short): ${shortId}, Full ID: ${targetDecisionId}`);
    } else {
      const decisions = Array.from(this.pendingDecisions.values());
      if (decisions.length > 0 && !message.startsWith("?") && !message.startsWith("more info") && !message.startsWith("context")) {
        if (message.toLowerCase().includes('ÂêåÊÑè') || message.toLowerCase().includes('ok') || message.toLowerCase().includes('Â•Ω') ||
            message.toLowerCase().includes('ÊãíÁµï') || message.toLowerCase().includes('‰∏ç') ||
            message.includes('ÂõûË¶Ü:') || message.includes('ÂõûË¶ÜÔºö')) {
          decision = decisions.sort((a, b) => b.timestamp - a.timestamp)[0];
          targetDecisionId = decision.id;
          console.log(`‚öñÔ∏è [DECISION_SYSTEM] Action without ID, targeting most recent decision: ${targetDecisionId}`);
        }
      }
    }

    if (!decision) {
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] No matching decision found for action message: "${message}"`);
      return 'Êâæ‰∏çÂà∞Â∞çÊáâÁöÑÊ±∫Á≠ñË´ãÊ±ÇÔºåÊàñÊåá‰ª§‰∏çÂÆåÊï¥„ÄÇË´ãÁ¢∫Ë™çÊåá‰ª§Ê†ºÂºèÔºå‰æãÂ¶ÇÔºö„ÄåÂêåÊÑè abc123„ÄçÊàñ„Äå? abc123„Äç„ÄÇ';
    }

    let response = '';
    const lowerMessage = message.toLowerCase();
    const commandPart = lowerMessage.replace(actionIdMatch ? actionIdMatch[0] : '', '').trim();

    if (commandPart.startsWith('ÂêåÊÑè') || commandPart.startsWith('ok') || commandPart.startsWith('Â•Ω')) {
      response = await this.handleApproval(decision);
    } else if (commandPart.startsWith('ÊãíÁµï') || commandPart.startsWith('‰∏ç')) {
      response = await this.handleRejection(decision);
    } else if (message.includes('ÂõûË¶Ü:') || message.includes('ÂõûË¶ÜÔºö')) { 
      const customReply = message.replace(/ÂõûË¶Ü[:Ôºö]/g, '').replace(actionIdMatch ? actionIdMatch[0] : '', '').trim();
      response = await this.handleCustomReply(decision, customReply);
    } else if (commandPart.includes('Êõ¥Â§ö')) { 
      const moreContext = enhancedAI.getGroupContext(decision.context.groupId, 20);
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] 'Êõ¥Â§ö' (legacy) command for decision ${targetDecisionId}.`);
      return `Êõ¥Â§öÂ∞çË©±Á¥ÄÈåÑÔºö\n${moreContext}\n\nË´ãÂõûË¶Ü‰Ω†ÁöÑÊ±∫ÂÆö (ID ${targetDecisionId.substr(-6)})`;
    } else {
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Unrecognized command for decision ${targetDecisionId}: "${commandPart}"`);
      return `ÁÑ°Ê≥ïË≠òÂà•Â∞çID [${targetDecisionId.substr(-6)}] ÁöÑÊåá‰ª§„ÄÇË´ã‰ΩøÁî®„ÄåÂêåÊÑè„Äç„ÄÅ„ÄåÊãíÁµï„ÄçÊàñ„ÄåÂõûË¶ÜÔºö[Ëá™Ë®ÇË®äÊÅØ]„Äç„ÄÇ`;
    }

    this.pendingDecisions.delete(targetDecisionId);
    this.decisionContexts.delete(targetDecisionId);
    console.log(`‚öñÔ∏è [DECISION_SYSTEM] Processed and deleted decision ${targetDecisionId}. Response: ${response}`);
    return `‚úÖ Â∑≤ËôïÁêÜÊ±∫Á≠ñ ${targetDecisionId.substr(-6)}\nÁµêÊûúÔºö${response}`;
  }

  async handleApproval(decision) {
    const replyMsg = 'Â•ΩÁöÑÔºåÊ≤íÂïèÈ°åÔºÅÊàëÊúÉÂÆâÊéíÔΩû';
    await this.sendReplyToSource(decision, replyMsg);
    return 'Â∑≤ÂêåÊÑè‰∏¶ÂõûË¶Ü';
  }

  async handleRejection(decision) {
    const replyMsg = 'Êä±Ê≠âÔºåÊàëÁèæÂú®‰∏çÂ§™Êñπ‰æøÔºå‰∏ãÊ¨°ÂÜçË™™ÂêßÔΩû';
    await this.sendReplyToSource(decision, replyMsg);
    return 'Â∑≤ÊãíÁµï‰∏¶ÂõûË¶Ü';
  }

  async handleCustomReply(decision, customReply) {
    await this.sendReplyToSource(decision, customReply);
    return `Â∑≤‰ΩøÁî®Ëá™Ë®ÇÂõûË¶ÜÔºö${customReply}`;
  }

  async sendReplyToSource(decision, message) {
    try {
      if (decision.sourceType === 'group') {
        await client.pushMessage(decision.sourceId, { type: 'text', text: message });
      } else {
        await client.pushMessage(decision.userId, { type: 'text', text: message });
      }
      console.log(`‚öñÔ∏è [DECISION_SYSTEM] Reply sent to source. Type: ${decision.sourceType}, TargetID: ${decision.sourceType === 'group' ? decision.sourceId : decision.userId}`);
    } catch (error) {
      console.error(`‚öñÔ∏è [DECISION_SYSTEM] Failed to send reply to source. Error:`, error);
    }
  }
}

// Â¢ûÂº∑ÁâàÊèêÈÜíÁ≥ªÁµ±
class EnhancedReminderSystem {
  constructor() {
    this.reminders = new Map();
    this.activeTimers = new Map();
    console.log('‚è∞ [REMINDER_SYSTEM] EnhancedReminderSystem initialized.');
  }

  parseTime(text) {
    console.log(`‚è∞ [REMINDER_SYSTEM] parseTime called with text: "${text}"`);
    let result = null;
    let reminderMethod = 'line'; // Default reminder method
    try {
      const now = new Date();
      let targetTime = null;
      let isAlarm = false;

      const lowerText = text.toLowerCase();
      const twilioKeywords = ['ÊâìÈõªË©±ÊèêÈÜí', 'Áî®ÈõªË©±Âè´Êàë', 'call alarm'];
      if (twilioKeywords.some(keyword => lowerText.includes(keyword))) {
        reminderMethod = 'twilio';
        console.log(`‚è∞ [REMINDER_SYSTEM] Twilio reminder method detected in text: "${text}"`);
      }

      if (lowerText.includes('ÂàÜÈêòÂæå') || lowerText.includes('ÂàÜÂæå')) {
        const match = lowerText.match(/(\d+)\s*ÂàÜ(?:Èêò)?Âæå/);
        if (match) {
          const minutes = parseInt(match[1]);
          targetTime = new Date(now.getTime() + minutes * 60000);
        }
      } else if (lowerText.includes('Â∞èÊôÇÂæå') || lowerText.includes('ÊôÇÂæå')) {
        const match = lowerText.match(/(\d+)\s*(?:Â∞è)?ÊôÇÂæå/);
        if (match) {
          const hours = parseInt(match[1]);
          targetTime = new Date(now.getTime() + hours * 3600000);
        }
      } else {
        const timeMatch = lowerText.match(/(\d{1,2}):(\d{2})/);
        if (timeMatch) {
          const hour = parseInt(timeMatch[1]);
          const minute = parseInt(timeMatch[2]);
          if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60) {
            targetTime = new Date();
            targetTime.setHours(hour, minute, 0, 0);
            if (targetTime <= now) {
              targetTime.setDate(targetTime.getDate() + 1);
            }
          }
        } else {
          const hourMatch = lowerText.match(/(\d{1,2})\s*Èªû/);
          if (hourMatch) {
            const hour = parseInt(hourMatch[1]);
            if (hour >= 0 && hour < 24) {
              targetTime = new Date();
              targetTime.setHours(hour, 0, 0, 0);
              if (targetTime <= now) {
                targetTime.setDate(targetTime.getDate() + 1);
              }
            }
          }
        }
        if (lowerText.includes('ÊòéÂ§©')) { 
            if (targetTime) { 
                 if(targetTime <= now && targetTime.getDate() === now.getDate()){ 
                    targetTime.setDate(targetTime.getDate() + 1);
                 } else if (targetTime.getDate() === now.getDate()){ 
                    targetTime.setDate(targetTime.getDate() + 1);
                 }
            } else { 
                targetTime = new Date();
                targetTime.setDate(targetTime.getDate() + 1);
                const specificTimeInTomorrow = lowerText.match(/(\d{1,2})[Èªû:](\d{0,2})?/); 
                if (specificTimeInTomorrow) {
                    const hour = parseInt(specificTimeInTomorrow[1]);
                    const minute = specificTimeInTomorrow[2] ? parseInt(specificTimeInTomorrow[2]) : 0;
                    targetTime.setHours(hour, minute, 0, 0);
                } else {
                    targetTime.setHours(9, 0, 0, 0); 
                }
            }
        }
      }
      
      if (targetTime) {
        isAlarm = lowerText.includes('Âè´') || lowerText.includes('Ëµ∑Â∫ä') || lowerText.includes('È¨ßÈêò') || reminderMethod === 'twilio';
        result = { time: targetTime, isAlarm, reminderMethod };
        console.log(`‚è∞ [REMINDER_SYSTEM] parseTime success: targetTime=${targetTime.toISOString()}, isAlarm=${isAlarm}, reminderMethod=${reminderMethod}`);
      } else {
        console.log(`‚è∞ [REMINDER_SYSTEM] parseTime failed to parse time from text: "${text}"`);
      }

    } catch (error) {
      console.error(`‚è∞ [REMINDER_SYSTEM] parseTime error for text "${text}":`, error);
    }
    return result;
  }

  createReminder(userId, title, targetTime, isAlarm = false, reminderMethod = 'line') {
    console.log(`‚è∞ [REMINDER_SYSTEM] createReminder called with: userId=${userId}, title="${title}", targetTime=${targetTime.toISOString()}, isAlarm=${isAlarm}, reminderMethod=${reminderMethod}`);
    const reminderId = `reminder-${userId}-${Date.now()}`;
    console.log(`‚è∞ [REMINDER_SYSTEM] Generated reminderId: ${reminderId}`);
    
    const reminder = {
      id: reminderId,
      userId,
      title,
      targetTime,
      isAlarm,
      reminderMethod, // Store the reminder method
      created: new Date()
    };
    console.log(`‚è∞ [REMINDER_SYSTEM] Reminder object created: ${JSON.stringify(reminder)}`);
    this.reminders.set(reminderId, reminder);
    
    const delay = targetTime.getTime() - Date.now();
    console.log(`‚è∞ [REMINDER_SYSTEM] Calculated delay for reminderId ${reminderId}: ${delay}ms`);
    
    if (delay > 0 && delay < 2147483647) { // JavaScript setTimeout ÈôêÂà∂
      const timerId = setTimeout(async () => {
        console.log(`‚è∞ [REMINDER_SYSTEM] setTimeout triggered for reminderId: ${reminderId}. Executing reminder.`);
        await this.executeReminder(reminderId);
      }, delay);
      
      this.activeTimers.set(reminderId, timerId);
      console.log(`‚è∞ [REMINDER_SYSTEM] setTimeout successfully created for reminderId ${reminderId}. Title: "${title}", Target: ${targetTime.toLocaleString('zh-TW')}`);
      return reminderId;
    } else if (delay <= 0) {
      console.log(`‚è∞ [REMINDER_SYSTEM] setTimeout not created for reminderId ${reminderId}: Delay is zero or negative (${delay}ms). Reminder might be in the past.`);
      this.reminders.delete(reminderId); 
      return null;
    } else { 
      console.log(`‚è∞ [REMINDER_SYSTEM] setTimeout not created for reminderId ${reminderId}: Delay is too long (${delay}ms). Exceeds setTimeout limit.`);
      this.reminders.delete(reminderId); 
      return null;
    }
  }

  async executeReminder(reminderId) {
    console.log(`‚è∞ [REMINDER_SYSTEM] executeReminder called for reminderId: ${reminderId}`);
    const reminder = this.reminders.get(reminderId);

    if (!reminder) {
      console.log(`‚è∞ [REMINDER_SYSTEM] Reminder not found for reminderId: ${reminderId}. Might have been deleted or already processed.`);
      this.activeTimers.delete(reminderId); 
      return;
    }
    console.log(`‚è∞ [REMINDER_SYSTEM] Found reminder: UserID=${reminder.userId}, Title="${reminder.title}", Method="${reminder.reminderMethod}"`);

    try {
      if (reminder.reminderMethod === 'twilio') {
        console.log(`‚è∞ [REMINDER_SYSTEM] Attempting Twilio call for reminderId: ${reminderId}`);
        if (twilioClient && OWNER_PHONE_NUMBER && OWNER_PHONE_NUMBER !== 'OWNER_PHONE_NUMBER_TO_CALL_PLACEHOLDER' && TWILIO_PHONE_NUMBER && TWILIO_PHONE_NUMBER !== 'YOUR_TWILIO_PHONE_NUMBER_PLACEHOLDER') {
          const twimlMessage = `<Response><Say language="zh-TW">‰Ω†Â•ΩÔºåÈÄôÊòØ‰æÜËá™È°ßÊôâÁëãLINE BotÁöÑÊèêÈÜíÔºö ${reminder.title}</Say></Response>`;
          console.log(`‚è∞ [REMINDER_SYSTEM] Twilio TwiML: ${twimlMessage}`);
          console.log(`‚è∞ [REMINDER_SYSTEM] Stubbing Twilio call. To: ${OWNER_PHONE_NUMBER}, From: ${TWILIO_PHONE_NUMBER}, Title: "${reminder.title}"`);
          // STUBBED: Actual call would be:
          // twilioClient.calls.create({
          //   twiml: twimlMessage,
          //   to: OWNER_PHONE_NUMBER, // Must be E.164 format
          //   from: TWILIO_PHONE_NUMBER // Must be a Twilio number
          // }).then(call => console.log(`‚è∞ [REMINDER_SYSTEM] Twilio call initiated, SID: ${call.sid}`))
          //   .catch(error => console.error(`‚è∞ [REMINDER_SYSTEM] Twilio call failed:`, error));
          console.log(`üìû [TWILIO_STUB] Twilio call for reminder "${reminder.title}" would be initiated here if credentials were live and call uncommented.`);
        } else {
          console.warn(`‚è∞ [REMINDER_SYSTEM] Twilio client not available or phone numbers not configured/valid. Cannot make call for reminderId: ${reminderId}.`);
          console.warn(`üìû Twilio Client: ${twilioClient ? 'Available' : 'Not Available'}, Owner Phone: ${OWNER_PHONE_NUMBER}, Twilio Phone: ${TWILIO_PHONE_NUMBER}`);
          // Fallback to LINE message if Twilio call cannot be made
          const fallbackText = `üìû ÂéüÂÆöÈõªË©±ÊèêÈÜíÂ§±ÊïóÔºàÁ≥ªÁµ±Ë®≠ÂÆöÂïèÈ°åÔºâ„ÄÇ\n‚è∞ LINEÊèêÈÜíÔºö${reminder.title}`;
          await client.pushMessage(reminder.userId, { type: 'text', text: fallbackText });
          console.log(`‚è∞ [REMINDER_SYSTEM] Sent fallback LINE reminder for ${reminderId} due to Twilio configuration issue.`);
        }
      } else { // Default to 'line'
        const reminderText = `‚è∞ ${reminder.isAlarm ? 'È¨ßÈêò' : 'ÊèêÈÜí'}ÊôÇÈñìÂà∞ÔºÅ

üìù ${reminder.title}
‚è±Ô∏è Ë®≠ÂÆöÊôÇÈñìÔºö${reminder.created.toLocaleString('zh-TW')}

${reminder.isAlarm ? '‚òÄÔ∏è Ëµ∑Â∫äÂõâÔºÅÊñ∞ÁöÑ‰∏ÄÂ§©ÈñãÂßã‰∫ÜÔºÅ' : 'Ë®òÂæóËôïÁêÜÈÄô‰ª∂‰∫ãÂñîÔºÅ'}`;
        console.log(`‚è∞ [REMINDER_SYSTEM] Prepared LINE reminderText for ${reminderId}: "${reminderText.replace(/\n/g, "\\n")}"`);
        try {
          await client.pushMessage(reminder.userId, { type: 'text', text: reminderText });
          console.log(`‚è∞ [REMINDER_SYSTEM] Successfully sent LINE reminder pushMessage for reminderId: ${reminderId} to userId: ${reminder.userId}`);
        } catch (pushError) {
          console.error(`‚è∞ [REMINDER_SYSTEM] Failed to send LINE reminder pushMessage for reminderId: ${reminderId} to userId: ${reminder.userId}. Error:`, pushError);
        }
      }
    } catch (error) {
      console.error(`‚è∞ [REMINDER_SYSTEM] Error preparing reminder for reminderId: ${reminderId}. Error:`, error);
    } finally {
      this.reminders.delete(reminderId);
      this.activeTimers.delete(reminderId);
      console.log(`‚è∞ [REMINDER_SYSTEM] Deleted reminder and activeTimer for reminderId: ${reminderId} from maps.`);
    }
  }

  extractTitle(text) {
    console.log(`‚è∞ [REMINDER_SYSTEM] extractTitle called with text: "${text}"`);
    let title = text;
    
    // ÁßªÈô§ÊôÇÈñìÁõ∏ÈóúË©ûË™û
    const timePatterns = [
      /\d+\s*ÂàÜ(?:Èêò)?Âæå/g,
      /\d+\s*(?:Â∞è)?ÊôÇÂæå/g,
      /\d{1,2}:\d{2}/g,
      /\d{1,2}\s*Èªû/g,
      /ÊòéÂ§©/g,
      /ÊèêÈÜíÊàë/g,
      /Âè´Êàë/g,
      /Ëµ∑Â∫ä/g,
      /È¨ßÈêò/g,
      /Âπ´ÊàëË®≠/g,
      /Ë®≠ÂÆö‰∏ÄÂÄã/g,
      /ÊâìÈõªË©±ÊèêÈÜí/gi, 
      /Áî®ÈõªË©±Âè´Êàë/gi,
      /call alarm/gi
    ];
    
    timePatterns.forEach(pattern => {
      title = title.replace(pattern, '');
    });
    
    title = title.replace(/ÁöÑ$/,'').trim(); 

    if (!title) {
      if (text.includes('Ëµ∑Â∫ä') || text.includes('È¨ßÈêò')) {
        title = 'Ëµ∑Â∫äÈ¨ßÈêò';
      } else if (text.includes('ÈñãÊúÉ')) {
        title = 'ÈñãÊúÉÊèêÈÜí';
      } else if (text.includes('ÂêÉËó•')) {
        title = 'ÂêÉËó•ÊèêÈÜí';
      } else {
        title = 'ÊèêÈÜí‰∫ãÈ†Ö';
      }
    }
    console.log(`‚è∞ [REMINDER_SYSTEM] Extracted title: "${title}" from text: "${text}"`);
    return title;
  }

  listReminders(userId) {
    const userReminders = Array.from(this.reminders.values())
      .filter(r => r.userId === userId)
      .sort((a, b) => a.targetTime - b.targetTime);
    
    if (userReminders.length === 0) {
      return '‰Ω†ÁõÆÂâçÊ≤íÊúâË®≠ÂÆö‰ªª‰ΩïÊèêÈÜí';
    }
    
    let list = 'üìã ‰Ω†ÁöÑÊèêÈÜíÊ∏ÖÂñÆÔºö\n\n';
    userReminders.forEach((r, index) => {
      list += `${index + 1}. ${r.title}\n`;
      list += `   ‚è∞ ${r.targetTime.toLocaleString('zh-TW')}\n\n`;
    });
    
    return list;
  }
}

// Á∂≤Ë∑ØÊêúÂ∞ãÂäüËÉΩ
class WebSearchSystem {
  constructor() {
    console.log('üîç [WEB_SEARCH_SYSTEM] WebSearchSystem initialized.');
  }

  async search(query) {
    console.log(`üîç [WEB_SEARCH_SYSTEM] search called with query: "${query}"`);
    let finalResultText = '';
    try {
      const searchUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
      console.log(`üîç [WEB_SEARCH_SYSTEM] Constructed DuckDuckGo searchUrl: ${searchUrl}`);
      
      const response = await axios.get(searchUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        },
        timeout: 10000
      });
      console.log(`üîç [WEB_SEARCH_SYSTEM] DuckDuckGo response status: ${response.status}`);

      const results = this.parseSearchResults(response.data);
      console.log(`üîç [WEB_SEARCH_SYSTEM] parseSearchResults returned ${results.length} results.`);
      
      if (results.length === 0) {
        finalResultText = `ü§î ÈóúÊñº„Äå${query}„ÄçÔºåÊàëÊâæ‰∏çÂà∞Áõ¥Êé•ÁöÑÁ∂≤È†ÅÁµêÊûúÔºåËÆìÊàëË©¶Ë©¶Áî®AIÁ∏ΩÁµê‰∏Ä‰∏ã„ÄÇ`;
        // Force fallback to Gemini by throwing a custom error or by re-throwing a generic one after logging
        throw new Error("No results from DuckDuckGo parsing, attempting AI fallback.");
      }

      let resultText = `üîç ÊêúÂ∞ã„Äå${query}„ÄçÁöÑÁµêÊûúÔºö\n\n`;
      results.slice(0, 3).forEach((result, index) => {
        resultText += `${index + 1}. ${result.title}\n`;
        resultText += `${result.snippet}\n`;
        resultText += `üîó ${result.link}\n\n`;
      });
      finalResultText = resultText;

    } catch (error) {
      console.error(`üîç [WEB_SEARCH_SYSTEM] DuckDuckGo search failed or parsing yielded no results. Error: ${error.message}`);
      if (error.response) {
        console.error(`üîç [WEB_SEARCH_SYSTEM] DDG Error response status: ${error.response.status}`);
        console.error(`üîç [WEB_SEARCH_SYSTEM] DDG Error response data: ${JSON.stringify(error.response.data).substring(0, 200)}...`);
      } else if (error.request) {
        console.error('üîç [WEB_SEARCH_SYSTEM] DDG Error request: The request was made but no response was received');
      }
      
      console.log(`üîç [WEB_SEARCH_SYSTEM] Falling back to Gemini AI for query: "${query}"`);
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-002" });
        const prompt = `Áî®Êà∂ÊÉ≥Ë¶ÅÊêúÂ∞ãÈóúÊñº„Äå${query}„ÄçÁöÑË≥áË®äÔºå‰ΩÜÁõ¥Êé•Á∂≤È†ÅÊêúÂ∞ãÊ≤íÊúâÁµêÊûú„ÄÇË´ãÊ†πÊìö‰Ω†ÁöÑÁü•Ë≠òÂ∫´ÔºåÊèê‰æõÈóúÊñº„Äå${query}„ÄçÁöÑÁõ∏ÈóúÁü•Ë≠òÂíåË¶ãËß£ÔºàÁ¥Ñ150Â≠óÔºâ„ÄÇ`;
        console.log(`üîç [WEB_SEARCH_SYSTEM] Prompt to Gemini: "${prompt}"`);
        
        const result = await model.generateContent(prompt);
        const geminiResponse = await result.response;
        const geminiText = geminiResponse.text();
        console.log(`üîç [WEB_SEARCH_SYSTEM] Gemini response text (first 100 chars): "${geminiText.substring(0,100).replace(/\n/g, "\\n")}"`);
        finalResultText = `üí° ÈóúÊñº„Äå${query}„ÄçÔºö\n\n${geminiText}`;
        
      } catch (aiError) {
        console.error(`üîç [WEB_SEARCH_SYSTEM] Gemini AI fallback also failed. AI Error: ${aiError.message}`);
        finalResultText = 'Êä±Ê≠âÔºåÁõÆÂâçÊêúÂ∞ãÂäüËÉΩÈÅáÂà∞‰∏Ä‰∫õÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
      }
    }
    console.log(`üîç [WEB_SEARCH_SYSTEM] Final resultText (first 100 chars): "${finalResultText.substring(0,100).replace(/\n/g, "\\n")}"`);
    return finalResultText;
  }

  parseSearchResults(html) {
    console.log(`üîç [WEB_SEARCH_SYSTEM] parseSearchResults called with HTML (first 300 chars): "${html.substring(0, 300).replace(/\n/g, "\\n")}"`);
    const results = [];
    const resultPattern = /<a class="result__a"[^>]*href="([^"]+)"[^>]*>([^<]+)<\/a>[\s\S]*?<a class="result__snippet"[^>]*>([^<]+)<\/a>/gi;
    
    let match;
    while ((match = resultPattern.exec(html)) !== null) {
      results.push({
        link: decodeURIComponent(match[1].replace('/l/?kh=-1&uddg=', '')), 
        title: match[2].trim().replace(/<b>|<\/b>/gi, ''), 
        snippet: match[3].trim().replace(/<b>|<\/b>/gi, '') 
      });
      
      if (results.length >= 5) break; 
    }
    console.log(`üîç [WEB_SEARCH_SYSTEM] Extracted ${results.length} results from HTML using regex.`);
    return results;
  }
}

// ÈõªÂΩ±Êü•Ë©¢Á≥ªÁµ±
class MovieSystem {
  constructor() {
    console.log('üé¨ [MOVIE_SYSTEM] MovieSystem initialized.');
  }

  async searchMovies(query = '') {
    console.log(`üé¨ [MOVIE_SYSTEM] searchMovies called with query: "${query}"`);
    let movies = []; 
    try {
      let endpoint = 'https://api.themoviedb.org/3/movie/popular';
      let params = {
        language: 'zh-TW',
        page: 1
      };

      if (query && query.length > 0) {
        endpoint = 'https://api.themoviedb.org/3/search/movie';
        params.query = query;
        console.log(`üé¨ [MOVIE_SYSTEM] Searching for movies with query. Endpoint: ${endpoint}, Params: ${JSON.stringify(params)}`);
      } else {
        console.log(`üé¨ [MOVIE_SYSTEM] Fetching popular movies. Endpoint: ${endpoint}, Params: ${JSON.stringify(params)}`);
      }

      const response = await axios.get(endpoint, {
        headers: {
          'Authorization': `Bearer ${TMDB_API_KEY}`, 
          'Content-Type': 'application/json'
        },
        params: params,
        timeout: 10000
      });

      console.log(`üé¨ [MOVIE_SYSTEM] TMDB API response status: ${response.status}`);
      if (response.data && Array.isArray(response.data.results)) {
        console.log(`üé¨ [MOVIE_SYSTEM] TMDB API raw results count: ${response.data.results.length}`);
        if (response.data.results.length > 0) {
            console.log(`üé¨ [MOVIE_SYSTEM] First movie result: ${JSON.stringify(response.data.results[0].title)}`);
        }
        movies = response.data.results.slice(0, 5);
        console.log(`üé¨ [MOVIE_SYSTEM] Processed ${movies.length} movies after slicing.`);
      } else {
        console.error('üé¨ [MOVIE_SYSTEM] TMDB API response.data.results is not an array or undefined.', response.data);
        return 'Êä±Ê≠âÔºåÈõªÂΩ±Ë≥áÊñôÊ†ºÂºèÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
      }
      
      if (movies.length === 0) {
        console.log(`üé¨ [MOVIE_SYSTEM] No movies found for query: "${query}"`);
        return query ? `üé¨ Êâæ‰∏çÂà∞ÈóúÊñº„Äå${query}„ÄçÁöÑÈõªÂΩ±ÔºåË´ãË©¶Ë©¶ÂÖ∂‰ªñÈóúÈçµÂ≠ó„ÄÇ` : 'üé¨ ÁõÆÂâçÊ≤íÊúâÁÜ±ÈñÄÈõªÂΩ±Ë≥áË®ä„ÄÇ';
      }

      let movieList = query ? 
        `üé¨ „Äå${query}„ÄçÁöÑÊêúÂ∞ãÁµêÊûúÔºö\n\n` : 
        'üé¨ ÁÜ±ÈñÄÈõªÂΩ±Êé®Ëñ¶Ôºö\n\n';
      
      movies.forEach((movie, index) => {
        movieList += `${index + 1}. ${movie.title || 'Êú™Áü•Ê®ôÈ°å'}${movie.original_title && movie.original_title !== movie.title ? ` (${movie.original_title})` : ''}\n`;
        movieList += `‚≠ê Ë©ïÂàÜÔºö${movie.vote_average !== undefined ? movie.vote_average : 'N/A'}/10\n`;
        movieList += `üìÖ ‰∏äÊò†Êó•ÊúüÔºö${movie.release_date || 'Êú™Áü•Êó•Êúü'}\n`;
        if (movie.overview) {
          movieList += `üìù ${movie.overview.substring(0, 60)}...\n`;
        } else {
          movieList += `üìù Êö´ÁÑ°Á∞°‰ªã\n`;
        }
        movieList += '\n';
      });
      
      console.log(`üé¨ [MOVIE_SYSTEM] Generated movieList (first 100 chars): "${movieList.substring(0, 100).replace(/\n/g, "\\n")}"`);
      return movieList;

    } catch (error) {
      console.error('üé¨ [MOVIE_SYSTEM] searchMovies error:', error.message);
      if (error.response) {
        console.error('üé¨ [MOVIE_SYSTEM] Error response status:', error.response.status);
        console.error('üé¨ [MOVIE_SYSTEM] Error response data:', JSON.stringify(error.response.data));
        if (error.response.status === 401) {
          return 'Êä±Ê≠âÔºåÈõªÂΩ±Êü•Ë©¢APIË™çË≠âÂ§±ÊïóÔºåË´ãÊ™¢Êü•APIÈáëÈë∞Ë®≠ÂÆö„ÄÇ';
        } else if (error.response.status === 404) {
          return 'Êä±Ê≠âÔºåÊâæ‰∏çÂà∞ÊåáÂÆöÁöÑÈõªÂΩ±Ë≥áÊ∫êÔºåË´ãÁ¢∫Ë™çÊü•Ë©¢Ê¢ù‰ª∂„ÄÇ';
        }
      } else if (error.request) {
        console.error('üé¨ [MOVIE_SYSTEM] Error request:', 'The request was made but no response was received');
      } else {
        console.error('üé¨ [MOVIE_SYSTEM] Error details:', error);
      }
      return 'Êä±Ê≠âÔºåÈõªÂΩ±Êü•Ë©¢ÂäüËÉΩÊö´ÊôÇÁÑ°Ê≥ï‰ΩøÁî®ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
    }
  }
}

// Ë®äÊÅØËΩâÁôºÁ≥ªÁµ±
class MessageForwardSystem {
  constructor() {
    this.userList = new Map(); 
    this.updateCount = 0;
    console.log('üì® [MSG_FORWARD_SYSTEM] MessageForwardSystem initialized.');
  }

  async forwardMessage(targetName, message, sourceUserName) {
    console.log(`üì® [MSG_FORWARD_SYSTEM] forwardMessage called with: targetName="${targetName}", message="${message.substring(0, 50)}...", sourceUserName="${sourceUserName}"`);
    let resultMessage = '';
    try {
      const targetUser = this.findUserByName(targetName);
      console.log(`üì® [MSG_FORWARD_SYSTEM] findUserByName result for "${targetName}": ${JSON.stringify(targetUser)}`);
      
      if (!targetUser) {
        resultMessage = `Êâæ‰∏çÂà∞Áî®Êà∂„Äå${targetName}„ÄçÔºåË´ãÁ¢∫Ë™çÂêçÁ®±ÊòØÂê¶Ê≠£Á¢∫`;
        console.log(`üì® [MSG_FORWARD_SYSTEM] ${resultMessage}`);
        return resultMessage;
      }

      const forwardMsg = `üì® ‰æÜËá™ ${sourceUserName} ÁöÑË®äÊÅØÔºö\n\n${message}`;
      console.log(`üì® [MSG_FORWARD_SYSTEM] Prepared forwardMsg for userId ${targetUser.userId}: "${forwardMsg.substring(0,100).replace(/\n/g, "\\n")}"`);
      
      try {
        await client.pushMessage(targetUser.userId, { type: 'text', text: forwardMsg });
        resultMessage = `‚úÖ Ë®äÊÅØÂ∑≤ËΩâÁôºÁµ¶ ${targetName} (ID: ${targetUser.userId.substring(0,10)}...)`;
        console.log(`üì® [MSG_FORWARD_SYSTEM] Successfully sent pushMessage to ${targetUser.userId}`);
      } catch (pushError) {
        console.error(`üì® [MSG_FORWARD_SYSTEM] Failed to send pushMessage to ${targetUser.userId}. Error:`, pushError.message, pushError.originalError?.response?.data);
        resultMessage = `Ë®äÊÅØËΩâÁôºÁµ¶ ${targetName} Â§±ÊïóÔºåÂÖßÈÉ®ÈåØË™§„ÄÇ`;
      }
      return resultMessage;

    } catch (error) {
      console.error(`üì® [MSG_FORWARD_SYSTEM] General error in forwardMessage:`, error);
      resultMessage = 'Ë®äÊÅØËΩâÁôºÈÅéÁ®ã‰∏≠ÁôºÁîüÊú™Áü•ÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ';
      return resultMessage;
    }
  }

  findUserByName(name) {
    console.log(`üì® [MSG_FORWARD_SYSTEM] findUserByName called with name: "${name}"`);
    const matchingUsers = [];
    for (const [userId, userInfo] of this.userList) {
      if (userInfo.displayName.toLowerCase().includes(name.toLowerCase())) {
        matchingUsers.push({ userId, ...userInfo });
      }
    }

    if (matchingUsers.length === 0) {
      console.log(`üì® [MSG_FORWARD_SYSTEM] No user found matching name: "${name}"`);
      return null;
    }

    if (matchingUsers.length > 1) {
      console.warn(`üì® [MSG_FORWARD_SYSTEM] Ambiguous name: "${name}". Found ${matchingUsers.length} users: ${JSON.stringify(matchingUsers.map(u => `${u.displayName}(${u.userId.substring(0,10)}...)`))}. Returning the first match.`);
    }
    
    const foundUser = matchingUsers[0];
    console.log(`üì® [MSG_FORWARD_SYSTEM] User found for name "${name}": ${foundUser.displayName} (ID: ${foundUser.userId})`);
    return foundUser;
  }

  updateUserList(userId, displayName) {
    const isNewUser = !this.userList.has(userId);
    const oldDisplayName = isNewUser ? null : this.userList.get(userId).displayName;
    
    this.userList.set(userId, { displayName, lastSeen: new Date() });
    this.updateCount++;

    if (isNewUser) {
      console.log(`üì® [MSG_FORWARD_SYSTEM] New user added to list: ${displayName} (ID: ${userId}). Total users: ${this.userList.size}.`);
    } else if (oldDisplayName !== displayName) {
      console.log(`üì® [MSG_FORWARD_SYSTEM] User display name updated: Old="${oldDisplayName}", New="${displayName}" (ID: ${userId}). Total users: ${this.userList.size}.`);
    }
    if (this.updateCount % 10 === 0) {
      console.log(`üì® [MSG_FORWARD_SYSTEM] updateUserList has been called ${this.updateCount} times. Current userList size: ${this.userList.size}.`);
    }
  }
}

// Â¢ûÂº∑ÁâàÁßÅË®äÁ≥ªÁµ±
class EnhancedPrivateMessageSystem {
  constructor() {
    console.log('üí¨ [ENHANCED_PM_SYSTEM] EnhancedPrivateMessageSystem initialized.');
  }

  async handlePrivateMessage(userId, userName, message) {
    if (userId === OWNER_LINE_ID) {
      return await this.handleOwnerMessage(message);
    }
    
    return await enhancedAI.generateReply(userId, message, { isGroup: false });
  }

  async handleOwnerMessage(message) {
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] handleOwnerMessage received: "${message}"`);
    if (decisionSystem.pendingDecisions.size > 0) {
      const decisionResponse = await decisionSystem.processOwnerDecision(message, OWNER_LINE_ID);
      if (decisionResponse && !decisionResponse.includes('Êâæ‰∏çÂà∞Â∞çÊáâÁöÑÊ±∫Á≠ñË´ãÊ±Ç')) {
        console.log(`üí¨ [ENHANCED_PM_SYSTEM] Decision system responded: "${decisionResponse}"`);
        return decisionResponse;
      } else if (decisionResponse === null) {
        console.log(`üí¨ [ENHANCED_PM_SYSTEM] Decision system is awaiting further input or has sent context.`);
        return null; 
      }
    }

    if (message.startsWith('/')) {
      console.log(`üí¨ [ENHANCED_PM_SYSTEM] Detected command: "${message}"`);
      return await this.handleCommand(message);
    }

    const forwardMatch = message.match(/(?:ÂëäË®¥|Ë∑ü)\s*([^Ë™™:]+?)\s*(?:Ë™™|:)(.+)/);
    if (forwardMatch) {
      console.log(`üí¨ [ENHANCED_PM_SYSTEM] Detected message forward pattern in: "${message}"`);
      return await this.handleMessageForward(message, forwardMatch);
    }
    
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] No specific handler for owner message, passing to AI: "${message}"`);
    return await enhancedAI.generateReply(OWNER_LINE_ID, message, { isGroup: false });
  }

  async handleCommand(command) {
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] handleCommand called with: "${command}"`);
    const cmd = command.substring(1).toLowerCase().split(' ')[0];
    let response = '';
    switch (cmd) {
      case 'status':
        response = this.getSystemStatus();
        break;
      case 'users':
        response = this.getUserReport();
        break;
      case 'reminders':
        response = reminderSystem.listReminders(OWNER_LINE_ID);
        break;
      case 'decisions':
        response = this.getPendingDecisions();
        break;
      case 'help':
        response = this.getHelpMenu();
        break;
      default:
        response = 'Êú™Áü•Êåá‰ª§ÔºåËº∏ÂÖ• /help Êü•ÁúãÂèØÁî®Êåá‰ª§';
    }
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] Command "${cmd}" generated response (first 50 chars): "${response.substring(0,50).replace(/\n/g, "\\n")}"`);
    return response;
  }

  async handleMessageForward(originalMessage, match) {
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] handleMessageForward called with originalMessage: "${originalMessage}"`);
    
    const targetName = match[1].trim();
    const content = match[2].trim();
    
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] Parsed for forwarding: targetName="${targetName}", content="${content.substring(0,50)}..."`);
    
    if (!targetName || !content) {
        const errorMsg = 'Ë®äÊÅØËΩâÁôºÊ†ºÂºèÈåØË™§„ÄÇË´ã‰ΩøÁî®Ôºö„ÄåÂëäË®¥ [ÂêçÂ≠ó] [Ë®äÊÅØÂÖßÂÆπ]„ÄçÊàñ„ÄåË∑ü [ÂêçÂ≠ó] Ë™™ [Ë®äÊÅØÂÖßÂÆπ]„Äç';
        console.log(`üí¨ [ENHANCED_PM_SYSTEM] Forwarding format error. Parsed: targetName="${targetName}", content="${content}"`);
        return errorMsg;
    }
    
    const forwardResult = await messageForward.forwardMessage(targetName, content, 'È°ßÊôâÁëã');
    console.log(`üí¨ [ENHANCED_PM_SYSTEM] messageForward.forwardMessage result: "${forwardResult}"`);
    return forwardResult;
  }

  getSystemStatus() {
    const statusReport = `ü§ñ Á≥ªÁµ±ÁãÄÊÖãÂ†±Âëä

‚è∞ ÊèêÈÜíÁ≥ªÁµ±ÔºöÊ≠£Â∏∏Ôºà${reminderSystem.reminders.size} ÂÄãÊ¥ªË∫çÊèêÈÜíÔºâ
üß† AIÁ≥ªÁµ±ÔºöÊ≠£Â∏∏
‚öñÔ∏è Ê±∫Á≠ñÁ≥ªÁµ±ÔºöÊ≠£Â∏∏Ôºà${decisionSystem.pendingDecisions.size} ÂÄãÂæÖËôïÁêÜÔºâ
üîç ÊêúÂ∞ãÁ≥ªÁµ±ÔºöÊ≠£Â∏∏
üé¨ ÈõªÂΩ±Á≥ªÁµ±ÔºöÊ≠£Â∏∏
üì® ËΩâÁôºÁ≥ªÁµ±ÔºöÊ≠£Â∏∏ÔºàÂ∑≤Áü•ËÅØÁµ°‰∫∫ ${messageForward.userList.size} ‰∫∫Ôºâ
üí¨ Â∞çË©±Ë®òÈåÑÔºö${enhancedAI.conversations.size} Á≠Ü
üë• Áî®Êà∂ÂÄã‰∫∫Ë≥áÊñôÔºö${enhancedAI.userProfiles.size} ‰∫∫

‚úÖ ÊâÄÊúâÁ≥ªÁµ±ÈÅã‰ΩúÊ≠£Â∏∏ÔºÅ`;
    return statusReport;
  }

  getUserReport() {
    const users = Array.from(messageForward.userList.entries()); 
    let report = `üë• Â∑≤Áü•ËÅØÁµ°‰∫∫ÂàóË°® (${users.length} ‰∫∫)Ôºö\n\n`;
    
    const sortedUsers = users
      .map(([userId, data]) => ({ userId, ...data })) 
      .sort((a, b) => b.lastSeen - a.lastSeen)
      .slice(0, 20); 
    
    sortedUsers.forEach((user, index) => {
      report += `${index + 1}. ${user.displayName} (ID: ...${user.userId.slice(-10)})\n`;
      report += `   üïê ÊúÄÂæå‰∫íÂãïÔºö${user.lastSeen.toLocaleString('zh-TW')}\n\n`;
    });
    
    if (users.length > sortedUsers.length) {
        report += `...ÈÇÑÊúâ ${users.length - sortedUsers.length} ‰ΩçÂÖ∂‰ªñËÅØÁµ°‰∫∫„ÄÇ`;
    }
    if (users.length === 0) {
        report = 'ÁõÆÂâçÊ≤íÊúâÂ∑≤Áü•ÁöÑËÅØÁµ°‰∫∫„ÄÇÁï∂Áî®Êà∂ËàáÊ©üÂô®‰∫∫‰∫íÂãïÊôÇÔºåÊúÉË¢´Âä†ÂÖ•ÂàóË°®„ÄÇ';
    }
    return report;
  }

  getPendingDecisions() {
    const decisions = Array.from(decisionSystem.pendingDecisions.values())
        .filter(d => new Date() - d.timestamp < 3600000); 
    
    if (decisions.length === 0) {
      return 'ÁõÆÂâçÊ≤íÊúâ1Â∞èÊôÇÂÖßÂæÖËôïÁêÜÁöÑÊ±∫Á≠ñ„ÄÇ';
    }

    let report = `‚öñÔ∏è ÂæÖËôïÁêÜÊ±∫Á≠ñ (1Â∞èÊôÇÂÖß)Ôºö\n\nÂÖ± ${decisions.length} ÂÄã\n\n`;
    
    decisions.sort((a,b) => a.timestamp - b.timestamp).forEach((d, index) => { 
      report += `${index + 1}. [${d.id.substr(-6)}] (‰æÜËá™: ${d.userName})\n`;
      report += `   üí¨ ${d.message.substring(0,50)}...\n`;
      report += `   ‚è∞ ${d.timestamp.toLocaleString('zh-TW')}\n\n`;
    });
    
    return report;
  }

  getHelpMenu() {
    return `üìö ‰∏ª‰∫∫Â∞àÁî®Êåá‰ª§

Âü∫Êú¨Êåá‰ª§Ôºö
/status - Á≥ªÁµ±ÁãÄÊÖã
/users - Áî®Êà∂Â†±Âëä
/reminders - Êü•ÁúãÊèêÈÜí
/decisions - ÂæÖËôïÁêÜÊ±∫Á≠ñ
/help - È°ØÁ§∫Ê≠§ÈÅ∏ÂñÆ

Ë®äÊÅØËΩâÁôºÔºö
ÂëäË®¥[ÂêçÂ≠ó] [Ë®äÊÅØ] - ËΩâÁôºË®äÊÅØ
‰æãÔºöÂëäË®¥Â∞èÊòé Á≠â‰∏Ä‰∏ãÈñãÊúÉ

Ê±∫Á≠ñÂõûË¶ÜÔºö
‚Ä¢ ÂõûË¶ÜÊ±∫Á≠ñID + ÂêåÊÑè/ÊãíÁµï
‚Ä¢ ÂõûË¶ÜÔºö[Ëá™Ë®ÇË®äÊÅØ]
‚Ä¢ ? - Êü•ÁúãÊõ¥Â§öË≥áË®ä

ÂÖ∂‰ªñÂäüËÉΩÊúÉËá™ÂãïÂà§Êñ∑Âü∑Ë°å`;
  }
}

// ÂàùÂßãÂåñÁ≥ªÁµ±
const enhancedAI = new EnhancedAISystem();
const decisionSystem = new EnhancedDecisionSystem();
const reminderSystem = new EnhancedReminderSystem();
const privateMessage = new EnhancedPrivateMessageSystem();
const webSearch = new WebSearchSystem();
const movieSystem = new MovieSystem();
const messageForward = new MessageForwardSystem();

// Reply Token ÁÆ°ÁêÜ
class ReplyTokenManager {
  constructor() {
    this.usedTokens = new Set();
    this.cleanupInterval = setInterval(() => this.cleanup(), 300000);
  }

  isUsed(token) { return this.usedTokens.has(token); }
  markUsed(token) { this.usedTokens.add(token); }
  cleanup() { this.usedTokens.clear(); }
}

const tokenManager = new ReplyTokenManager();

// ÂÆâÂÖ®ÂõûË¶ÜÂáΩÊï∏
async function safeReply(replyToken, message, retryCount = 0) {
  try {
    if (tokenManager.isUsed(replyToken)) return false;
    tokenManager.markUsed(replyToken);
    
    const formattedMessage = typeof message === 'string' ? 
      { type: 'text', text: message.substring(0, MAX_MESSAGE_LENGTH) } : message;
    
    await client.replyMessage(replyToken, formattedMessage);
    return true;
    
  } catch (error) {
    console.error(`ÂõûË¶ÜÂ§±Êïó (${retryCount + 1}):`, error);
    
    if (retryCount < 1) {
      const simpleText = typeof message === 'string' ? message : 
        (message.text || message.altText || 'ÂõûË¶ÜË®äÊÅØ');
      
      try {
        await client.replyMessage(replyToken, { 
          type: 'text', 
          text: simpleText.substring(0, MAX_MESSAGE_LENGTH) 
        });
        return true;
      } catch (simpleError) {
        console.error('Á∞°ÂñÆÂõûË¶Ü‰πüÂ§±Êïó:', simpleError);
      }
    }
    
    return false;
  }
}

// ÂÆâÂÖ®Êé®ÈÄÅÂáΩÊï∏
async function safePushMessage(targetId, message, retryCount = 0) {
  try {
    const formattedMessage = typeof message === 'string' ? 
      { type: 'text', text: message.substring(0, MAX_MESSAGE_LENGTH) } : message;
    
    await client.pushMessage(targetId, formattedMessage);
    return true;
    
  } catch (error) {
    console.error(`Êé®ÈÄÅÂ§±Êïó (${retryCount + 1}):`, error);
    
    if (retryCount < 1) {
      const simpleText = typeof message === 'string' ? message : 
        (message.text || message.altText || 'Êé®ÈÄÅË®äÊÅØ');
      
      try {
        await client.pushMessage(targetId, { 
          type: 'text', 
          text: simpleText.substring(0, MAX_MESSAGE_LENGTH) 
        });
        return true;
      } catch (simpleError) {
        console.error('Á∞°ÂñÆÊé®ÈÄÅ‰πüÂ§±Êïó:', simpleError);
      }
    }
    
    return false;
  }
}

// Âà§Êñ∑ÂáΩÊï∏
function isReminderQuery(text) {
  const reminderKeywords = ['ÊèêÈÜíÊàë', 'ÊèêÈÜí', 'ÂàÜÈêòÂæå', 'Â∞èÊôÇÂæå', 'Âè´Êàë', 'Ëµ∑Â∫ä', 'È¨ßÈêò', 'ÊòéÂ§©', 'ÊâìÈõªË©±ÊèêÈÜí', 'Áî®ÈõªË©±Âè´Êàë', 'call alarm'];
  return reminderKeywords.some(keyword => text.toLowerCase().includes(keyword.toLowerCase())) && 
         (text.match(/\d/) || text.toLowerCase().includes('ÊòéÂ§©'));
}

function isMovieQuery(text) {
  const movieKeywords = ['ÈõªÂΩ±', 'ÂΩ±Áâá', '‰∏äÊò†', 'Á•®Êàø', 'Â•ΩÁúãÁöÑÁâá'];
  return movieKeywords.some(keyword => text.includes(keyword));
}

function isWebSearchQuery(text) {
  const searchKeywords = ['ÊêúÂ∞ã', 'Êü•Ë©¢', 'Êü•‰∏Ä‰∏ã', 'Âπ´ÊàëÊü•', 'ÊòØ‰ªÄÈ∫º', 'ÊÄéÈ∫ºËæ¶'];
  return searchKeywords.some(keyword => text.includes(keyword));
}

function isFunctionMenuQuery(text) {
  const menuKeywords = ['ÂäüËÉΩ', 'ÈÅ∏ÂñÆ', 'Âπ´Âä©', 'help', 'ÊïôÂ≠∏', 'ÊÄéÈ∫ºÁî®'];
  return menuKeywords.some(keyword => text.toLowerCase().includes(keyword));
}

// ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû
app.get('/', (req, res) => {
  const currentTime = new Date().toLocaleString('zh-TW', { timeZone: 'Asia/Taipei' });
  
  res.send(\`
    <!DOCTYPE html>
    <html>
    <head>
      <title>È°ßÊôâÁëãÁöÑÂ¢ûÂº∑Áâà LINE Bot</title>
      <style>
        body { 
          font-family: Arial, sans-serif; 
          margin: 20px; 
          background-color: #f5f5f5; 
        }
        h1, h2 { color: #333; }
        .status-box {
          background-color: #e8f5e8; 
          padding: 15px; 
          border-radius: 8px;
          margin: 10px 0;
        }
        .feature-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 15px;
          margin: 20px 0;
        }
        .feature-card {
          background: white;
          padding: 15px;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .feature-card h3 {
          margin-top: 0;
          color: #2196F3;
        }
        ul li { margin: 5px 0; }
        .chart {
          width: 100%;
          height: 200px;
          background: linear-gradient(to right, #4CAF50 0%, #2196F3 100%);
          border-radius: 8px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          font-size: 24px;
          margin: 20px 0;
        }
      </style>
    </head>
    <body>
      <h1>ü§ñ È°ßÊôâÁëãÁöÑÂ¢ûÂº∑Áâà LINE Bot v11.0</h1>
      <p><strong>üáπüáº Âè∞ÁÅ£ÊôÇÈñìÔºö\${currentTime}</strong></p>
      <p><strong>üîë Ê©üÂô®‰∫∫‰∏ª‰∫∫Ôºö\${OWNER_LINE_ID}</strong></p>
      
      <div class="chart">
        Á≥ªÁµ±ÈÅãË°åÁãÄÊÖãÔºöÂÑ™ËâØ ‚ú®
      </div>
      
      <h2>üìä Âç≥ÊôÇÁ≥ªÁµ±ÁãÄÊÖã</h2>
      <div class="status-box">
        <p>üß† AIÁ≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠ÔºàÂ∞çË©±Ë®òÈåÑ \${enhancedAI.conversations.size} Á≠ÜÔºâ</p>
        <p>‚è∞ ÊèêÈÜíÁ≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠ÔºàÊ¥ªË∫çÊèêÈÜí \${reminderSystem.reminders.size} ÂÄãÔºâ</p>
        <p>‚öñÔ∏è Ê±∫Á≠ñÁ≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠ÔºàÂæÖËôïÁêÜ \${decisionSystem.pendingDecisions.size} ÂÄãÔºâ</p>
        <p>üîç ÊêúÂ∞ãÁ≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠</p>
        <p>üé¨ ÈõªÂΩ±Á≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠</p>
        <p>üì® Ë®äÊÅØËΩâÁôºÁ≥ªÁµ±ÔºöÈÅã‰Ωú‰∏≠ÔºàÂ∑≤Áü•ËÅØÁµ°‰∫∫ \${messageForward.userList.size} ‰∫∫Ôºâ</p>
        <p>üë• Áî®Êà∂ÂÄã‰∫∫Ë≥áÊñôÔºö\${enhancedAI.userProfiles.size} ‰∫∫</p>
      </div>
      
      <h2>‚ú® Ê†∏ÂøÉÂäüËÉΩÁ∏ΩË¶Ω (Áî®Êà∂Ë¶ñËßí)</h2>
      <div class="feature-grid">
        <div class="feature-card">
          <h3>üß† Êô∫ËÉΩËÅäÂ§©</h3>
          <ul>
            <li>ËàáAIÈÄ≤Ë°åËá™ÁÑ∂Â∞çË©±</li>
            <li>ÊîØÊè¥Áæ§ÁµÑ‰∏ä‰∏ãÊñáÁêÜËß£</li>
            <li>ÂÄãÊÄßÂåñ„ÄÅÂè£Ë™ûÂåñÂõûË¶Ü</li>
            <li>Èõ¢Á∑öÊôÇÊèê‰æõÂÇôÁî®ÂõûË¶Ü</li>
          </ul>
        </div>
        
        <div class="feature-card">
          <h3>‚è∞ ÊèêÈÜíËàáÈ¨ßÈêò</h3>
          <ul>
            <li>ÊîØÊè¥Â§öÁ®ÆÊôÇÈñìÊ†ºÂºè</li>
            <li>È¨ßÈêòÂäüËÉΩ (LINE / ÈõªË©±Ë™ûÈü≥)</li>
            <li>ÊèêÈÜíÊ∏ÖÂñÆÊü•Ë©¢ (‰∏ª‰∫∫)</li>
            <li>Êô∫ËÉΩÊ®ôÈ°åÊèêÂèñ</li>
          </ul>
        </div>
        
        <div class="feature-card">
          <h3>üîç Á∂≤Ë∑ØÊêúÂ∞ã</h3>
          <ul>
            <li>ÈÄèÈÅéÈóúÈçµÂ≠óÈÄ≤Ë°åÁ∂≤È†ÅÊêúÂ∞ã (Â¶Ç "ÊêúÂ∞ã...")</li>
            <li>DuckDuckGo ÂàùÊ≠•ÊêúÂ∞ã</li>
            <li>Ëã•ÁÑ°ÁµêÊûúÂâáÁî±AIÁ∏ΩÁµêÁü•Ë≠ò</li>
            <li>ÁµêÊßãÂåñÂëàÁèæÊêúÂ∞ãÁµêÊûú</li>
          </ul>
        </div>
        
        <div class="feature-card">
          <h3>üé¨ ÈõªÂΩ±Ë≥áË®ä</h3>
          <ul>
            <li>Êü•Ë©¢ÁÜ±ÈñÄÈõªÂΩ±</li>
            <li>ÈÄèÈÅéÈóúÈçµÂ≠óÊêúÂ∞ãÁâπÂÆöÈõªÂΩ±</li>
            <li>È°ØÁ§∫Ë©ïÂàÜ„ÄÅ‰∏äÊò†Êó•ÊúüËàáÁ∞°‰ªã</li>
          </ul>
        </div>

        <div class="feature-card">
          <h3>ü§ñ Êô∫ËÉΩË´ãÊ±ÇËôïÁêÜ</h3>
          <ul>
            <li>ÁâπÂÆöË´ãÊ±ÇÂ∞áÁî±AIËΩâÂëäÁúü‰∫∫ËôïÁêÜ</li>
            <li>Áî®Êà∂Â∞áÊî∂Âà∞ÊúÄÁµÇËôïÁêÜÂõûË¶Ü</li>
            <li>(Ê≠§ÈÅéÁ®ãÈÉ®ÂàÜËá™ÂãïÂåñ)</li>
          </ul>
        </div>

      </div>
      
      <h2>üìà ÂäüËÉΩ‰ΩøÁî®Áµ±Ë®à</h2>
      <div style="background: white; padding: 20px; border-radius: 8px;">
        <canvas id="statsChart" width="400" height="200"></canvas>
      </div>
      
      <h2>üîß v11.0 (ËøëÊúüËø≠‰ª£) Êõ¥Êñ∞ÂÖßÂÆπ</h2>
      <ul>
        <li>üìû **ÈõªË©±Ë™ûÈü≥ÊèêÈÜí**: Êñ∞Â¢ûTwilioÊï¥ÂêàÔºåÂèØÈÄèÈÅéË™ûÈü≥ÈÄöË©±ÈÄ≤Ë°åÊèêÈÜí (ÈúÄË®≠ÂÆöÁí∞Â¢ÉËÆäÊï∏)„ÄÇ</li>
        <li>üÜï **Ê±∫Á≠ñÁ≥ªÁµ±Âº∑Âåñ**: ‰∏ª‰∫∫ÁèæÂú®ÂèØ‰ª•ÈÄèÈÅé "? ID" Êåá‰ª§Êü•Ë©¢ÂæÖÊ±∫Á≠ñ‰∫ãÈ†ÖÁöÑË©≥Á¥∞Â∞çË©±‰∏ä‰∏ãÊñá„ÄÇ</li>
        <li>‚öôÔ∏è **ÊèêÈÜíÁ≥ªÁµ±Êó•Ë™åËàá‰øÆÂæ©**: Â¢ûÂº∑ÊèêÈÜíË®≠ÂÆöËàáÂü∑Ë°åÁöÑÊó•Ë™åË®òÈåÑÔºåÊèêÂçáÂïèÈ°åËøΩËπ§ËÉΩÂäõÔºõËôïÁêÜÊèêÈÜíÊôÇÈñìÂ∑≤ÈÅéÊàñÈÅéÈï∑ÁöÑÊÉÖÊ≥Å„ÄÇ</li>
        <li>üé¨ **ÈõªÂΩ±Á≥ªÁµ±Êó•Ë™åËàá‰øÆÂæ©**: Âº∑ÂåñÈõªÂΩ±Êü•Ë©¢ÁöÑÊó•Ë™åÔºåAPIÈåØË™§ËôïÁêÜÊõ¥Á¥∞Á∑ªÔºåË≥áÊñôÂëàÁèæÊõ¥Á©©ÂÆö„ÄÇ</li>
        <li>üåê **Á∂≤Ë∑ØÊêúÂ∞ãÊó•Ë™åËàáÂÑ™Âåñ**: Á∂≤Ë∑ØÊêúÂ∞ãÂäüËÉΩÂä†ÂÖ•ÂÆåÊï¥Êó•Ë™åÔºåÂÑ™ÂåñÊêúÂ∞ãÁµêÊûúËß£ÊûêËàáAIÂÇôÊè¥ÈÇèËºØ„ÄÇ</li>
        <li>üì® **Ë®äÊÅØËΩâÁôºÊó•Ë™åËàáÂº∑Âåñ**: Êñ∞Â¢ûË®äÊÅØËΩâÁôºÂäüËÉΩÊó•Ë™åÔºåÂº∑ÂåñÁî®Êà∂ÂêçÁ®±Ë≠òÂà•ËàáÊåá‰ª§Ëß£ÊûêÁöÑÊ∏ÖÊô∞Â∫¶„ÄÇ</li>
        <li>üìä **ÂäüËÉΩÂàóË°®Êõ¥Êñ∞**: ÂêåÊ≠•Êõ¥Êñ∞Ê©üÂô®‰∫∫ÂäüËÉΩÈÅ∏ÂñÆËàáÁãÄÊÖãÈ†ÅÈù¢ÔºåÁ¢∫‰øùË≥áË®ä‰∏ÄËá¥ÊÄß„ÄÇ</li>
        <li>üìù **ÂÖ®Èù¢Êó•Ë™åÁ≥ªÁµ±**: ÂêÑÊ†∏ÂøÉÊ®°ÁµÑÂùáÂ∑≤Âä†ÂÖ•Ë©≥Á¥∞Êó•Ë™åË®òÈåÑÔºåÊèêÂçáÁ≥ªÁµ±ÂèØÁ∂≠Ë≠∑ÊÄßËàáÂïèÈ°åË®∫Êñ∑ÊïàÁéá„ÄÇ</li>
      </ul>
      
      <script>
        // Á∞°ÂñÆÁöÑÁµ±Ë®àÂúñË°®
        const canvas = document.getElementById('statsChart');
        const ctx = canvas.getContext('2d');
        
        const data = [
          { label: 'AIÂ∞çË©±', value: \${enhancedAI.conversations.size}, color: '#4CAF50' },
          { label: 'Áî®Êà∂Êï∏', value: \${enhancedAI.userProfiles.size}, color: '#2196F3' },
          { label: 'ÊèêÈÜíÊï∏', value: \${reminderSystem.reminders.size}, color: '#FF9800' },
          { label: 'Ê±∫Á≠ñÊï∏', value: \${decisionSystem.pendingDecisions.size}, color: '#9C27B0' }
        ];
        
        const maxValue = Math.max(...data.map(d => d.value), 10);
        const barWidth = 80;
        const barSpacing = 20;
        
        data.forEach((item, index) => {
          const x = 50 + index * (barWidth + barSpacing);
          const height = (item.value / maxValue) * 150;
          const y = 180 - height;
          
          ctx.fillStyle = item.color;
          ctx.fillRect(x, y, barWidth, height);
          
          ctx.fillStyle = '#333';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(item.label, x + barWidth/2, 195);
          ctx.fillText(item.value, x + barWidth/2, y - 5);
        });
      </script>
    </body>
    </html>
  \`);
});

// Webhook Á´ØÈªû
app.post('/webhook', express.raw({type: 'application/json'}), async (req, res) => {
  const signature = req.get('X-Line-Signature');
  
  if (!signature) return res.status(401).send('Áº∫Â∞ëÁ∞ΩÂêçÊ®ôÈ†≠');

  const body = req.body.toString();
  const hash = crypto.createHmac('SHA256', config.channelSecret).update(body).digest('base64');

  if (signature !== hash) return res.status(401).send('Á∞ΩÂêçÈ©óË≠âÂ§±Êïó');

  let events;
  try {
    const parsedBody = JSON.parse(body);
    events = parsedBody.events;
  } catch (error) {
    return res.status(400).send('ÁÑ°ÊïàÁöÑ JSON');
  }

  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });

  events.forEach(event => {
    handleEvent(event).catch(error => {
      console.error('‰∫ã‰ª∂ËôïÁêÜÈåØË™§:', error);
    });
  });
});

// ‰∏ªË¶Å‰∫ã‰ª∂ËôïÁêÜÂáΩÊï∏
async function handleEvent(event) {
  try {
    if (event.type !== 'message' || event.message.type !== 'text') return;

    const userId = event.source.userId;
    const groupId = event.source.groupId;
    const messageText = event.message.text.trim();
    const replyToken = event.replyToken;
    const isGroup = !!groupId;
    
    let userName = 'ÊúãÂèã';
    let groupName = 'Áæ§ÁµÑ';
    try {
      if (groupId) {
        const profile = await client.getGroupMemberProfile(groupId, userId);
        userName = profile.displayName;
        try {
          const groupInfo = await client.getGroupSummary(groupId);
          groupName = groupInfo.groupName;
        } catch (e) { /*ÂøΩÁï•*/ }
      } else {
        const profile = await client.getProfile(userId);
        userName = profile.displayName;
      }
    } catch (error) {
      console.log('ÁÑ°Ê≥ïÁç≤ÂèñÁî®Êà∂ÂêçÁ®±');
    }

    messageForward.updateUserList(userId, userName);

    const context = { isGroup, groupId, userId, userName, groupName };
    let response = '';

    if (!isGroup) {
      response = await privateMessage.handlePrivateMessage(userId, userName, messageText);
      await safeReply(replyToken, response);
      return;
    }

    if (isFunctionMenuQuery(messageText)) {
      const flexMenu = {
        type: 'flex',
        altText: 'ÁÇ∫ÊÇ®ÊâìÈñãÂäüËÉΩÈÅ∏ÂñÆÔºåË´ãÂú®LINEÊáâÁî®Á®ãÂºè‰∏≠Êü•Áúã„ÄÇ',
        contents: {
          type: 'carousel',
          contents: [
            {
              type: 'bubble',
              header: {
                type: 'box',
                layout: 'vertical',
                contents: [
                  { type: 'text', text: 'üß† Êô∫ËÉΩËÅäÂ§©', weight: 'bold', size: 'xl', color: '#1DB446' }
                ]
              },
              body: {
                type: 'box',
                layout: 'vertical',
                spacing: 'md',
                contents: [
                  { 
                    type: 'text', 
                    text: 'ËàáAIËá™Áî±Â∞çË©±ÔºåÂïèÂïèÈ°åÔºåËÅäÂ§©„ÄÇÂú®Áæ§ÁµÑ‰∏≠ÊàëËÉΩÁêÜËß£‰∏ä‰∏ãÊñá‰∏¶ÂèÉËàáË®éË´ñ„ÄÇ', 
                    wrap: true, 
                    size: 'sm' 
                  }
                ]
              },
              footer: {
                type: 'box',
                layout: 'vertical',
                spacing: 'sm',
                contents: [
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#1DB446',
                    height: 'sm',
                    action: { type: 'message', label: '‰ªäÂ§©Â§©Ê∞£Â¶Ç‰ΩïÔºü', text: '‰ªäÂ§©Â§©Ê∞£Â¶Ç‰ΩïÔºü' }
                  },
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#1DB446',
                    height: 'sm',
                    action: { type: 'message', label: '‰Ω†Â•ΩÂóéÔºü', text: '‰Ω†Â•ΩÂóéÔºü' }
                  }
                ]
              }
            },
            {
              type: 'bubble',
              header: {
                type: 'box',
                layout: 'vertical',
                contents: [
                  { type: 'text', text: '‚è∞ ÊèêÈÜíËàáÈ¨ßÈêò', weight: 'bold', size: 'xl', color: '#FF6B6E' }
                ]
              },
              body: {
                type: 'box',
                layout: 'vertical',
                spacing: 'md',
                contents: [
                  { 
                    type: 'text', 
                    text: 'Ë®≠ÂÆöÊèêÈÜíÊàñÈ¨ßÈêò (LINEÊàñÈõªË©±Ë™ûÈü≥)„ÄÇ\n‰æã:„ÄåÊâìÈõªË©±ÊèêÈÜíÊàëÊòéÂ§©ÈñãÊúÉ„Äç', 
                    wrap: true, 
                    size: 'sm' 
                  }
                ]
              },
              footer: {
                type: 'box',
                layout: 'vertical',
                spacing: 'sm',
                contents: [
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#FF6B6E',
                    height: 'sm',
                    action: { type: 'message', label: '10ÂàÜÈêòÂæåÊèêÈÜíÊàëÂñùÊ∞¥', text: '10ÂàÜÈêòÂæåÊèêÈÜíÊàëÂñùÊ∞¥' }
                  },
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#FF6B6E',
                    height: 'sm',
                    action: { type: 'message', label: 'ÊòéÂ§©Êó©‰∏ä7ÈªûÂè´ÊàëËµ∑Â∫ä', text: 'ÊòéÂ§©Êó©‰∏ä7ÈªûÂè´ÊàëËµ∑Â∫ä' }
                  }
                ]
              }
            },
            {
              type: 'bubble',
              header: {
                type: 'box',
                layout: 'vertical',
                contents: [
                  { type: 'text', text: 'üîç Ë≥áË®äÊü•Ë©¢', weight: 'bold', size: 'xl', color: '#4A90E2' }
                ]
              },
              body: {
                type: 'box',
                layout: 'vertical',
                spacing: 'md',
                contents: [
                  { 
                    type: 'text', 
                    text: 'Êü•Ë©¢Á∂≤È†ÅË≥áË®äÊàñÈõªÂΩ±Ë©≥ÊÉÖ„ÄÇ‰æãÂ¶ÇÔºö„ÄåÊêúÂ∞ãÔºöAIÊúÄÊñ∞ÁôºÂ±ï„ÄçÊàñ„ÄåÈõªÂΩ±ÔºöÊòüÈöõÊïàÊáâ„Äç„ÄÇ', 
                    wrap: true, 
                    size: 'sm' 
                  }
                ]
              },
              footer: {
                type: 'box',
                layout: 'vertical',
                spacing: 'sm',
                contents: [
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#4A90E2',
                    height: 'sm',
                    action: { type: 'message', label: 'ÊêúÂ∞ãÔºöAIÊúÄÊñ∞ÁôºÂ±ï', text: 'ÊêúÂ∞ãÔºöAIÊúÄÊñ∞ÁôºÂ±ï' }
                  },
                  {
                    type: 'button',
                    style: 'primary',
                    color: '#4A90E2',
                    height: 'sm',
                    action: { type: 'message', label: 'ÈõªÂΩ±ÔºöÊòüÈöõÊïàÊáâ', text: 'ÈõªÂΩ±ÔºöÊòüÈöõÊïàÊáâ' }
                  }
                ]
              }
            }
          ]
        }
      };
      console.log('ü§ñ Sending Flex Menu for function query.'); // Added for explicit logging
      await safeReply(replyToken, flexMenu);
      
    } else if (isReminderQuery(messageText)) {
      console.log('Ê™¢Ê∏¨Âà∞ÊèêÈÜíË´ãÊ±Ç:', messageText);
      
      const timeInfo = reminderSystem.parseTime(messageText);
      
      if (timeInfo && timeInfo.time) {
        const title = reminderSystem.extractTitle(messageText);
        // Pass reminderMethod from timeInfo to createReminder
        const reminderId = reminderSystem.createReminder(userId, title, timeInfo.time, timeInfo.isAlarm, timeInfo.reminderMethod);
        
        if (reminderId) {
          let confirmText = `‚úÖ ${timeInfo.isAlarm ? 'È¨ßÈêò' : 'ÊèêÈÜí'}Ë®≠ÂÆöÊàêÂäüÔºÅ`;
          if (timeInfo.reminderMethod === 'twilio') {
            confirmText += '\nüìû Â∞á‰ª•ÈõªË©±Ë™ûÈü≥ÊñπÂºèÊèêÈÜí„ÄÇ';
          }

üìù Ê®ôÈ°åÔºö${title}
‚è∞ ÊôÇÈñìÔºö${timeInfo.time.toLocaleString('zh-TW', { 
  year: 'numeric',
  month: '2-digit', 
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit'
})}

ÊàëÊúÉÊ∫ñÊôÇ${timeInfo.isAlarm ? 'Âè´‰Ω†Ëµ∑Â∫ä' : 'ÊèêÈÜí‰Ω†'}ÔºÅ`;
          
          await safeReply(replyToken, confirmText);
        } else {
          await safeReply(replyToken, '‚ö†Ô∏è ÊèêÈÜíË®≠ÂÆöÂ§±ÊïóÔºåÊôÇÈñìÂèØËÉΩÂ§™ÈÅ†ÊàñÊ†ºÂºèÈåØË™§');
        }
      } else {
        const helpText = `‚è∞ ÊôÇÈñìÊ†ºÂºèË™™Êòé

ÊîØÊè¥Ê†ºÂºèÔºö
‚Ä¢ "10ÂàÜÈêòÂæåÊèêÈÜíÊàë‰ºëÊÅØ"
‚Ä¢ "2Â∞èÊôÇÂæåÊèêÈÜíÊàëÈñãÊúÉ"
‚Ä¢ "15:30ÊèêÈÜíÊàë"
‚Ä¢ "7ÈªûÂè´ÊàëËµ∑Â∫ä"
‚Ä¢ "ÊòéÂ§©8ÈªûÊèêÈÜíÊàë‰∏äÁè≠"
‚Ä¢ (ÂèØÂä†‰∏ä "ÊâìÈõªË©±ÊèêÈÜí" ‰ΩøÁî®Ë™ûÈü≥ÈÄöÁü•)

Ë´ãÂÜçË©¶‰∏ÄÊ¨°ÔΩû`;
        
        await safeReply(replyToken, helpText);
      }
      
    } else if (isMovieQuery(messageText)) {
      console.log('Ê™¢Ê∏¨Âà∞ÈõªÂΩ±Êü•Ë©¢:', messageText);
      
      let movieName = '';
      const searchMatch = messageText.match(/(?:ÊêúÂ∞ã|Êü•|Êâæ).*?ÈõªÂΩ±(.+)|ÈõªÂΩ±.*?(.+)/);
      if (searchMatch) {
        movieName = (searchMatch[1] || searchMatch[2] || '').trim();
      }
      
      const movieResults = await movieSystem.searchMovies(movieName);
      await safeReply(replyToken, movieResults);
      
    } else if (isWebSearchQuery(messageText)) {
      console.log('Ê™¢Ê∏¨Âà∞ÊêúÂ∞ãË´ãÊ±Ç:', messageText);
      
      let query = messageText;
      const searchMatch = messageText.match(/(?:ÊêúÂ∞ã|Êü•Ë©¢|Êü•‰∏Ä‰∏ã|Âπ´ÊàëÊü•)(.+)|(.+?)(?:ÊòØ‰ªÄÈ∫º|ÊÄéÈ∫ºËæ¶)/);
      if (searchMatch) {
        query = (searchMatch[1] || searchMatch[2] || messageText).trim();
      }
      
      const searchResults = await webSearch.search(query);
      await safeReply(replyToken, searchResults);
      
    } else {
      if (decisionSystem.shouldAskOwner(messageText, context)) {
        response = await decisionSystem.requestDecision(messageText, userId, userName, context, replyToken);
        await safeReply(replyToken, response);
      } else {
        response = await enhancedAI.generateReply(userId, messageText, context);
        await safeReply(replyToken, response);
      }
    }

  } catch (error) {
    console.error('‰∫ã‰ª∂ËôïÁêÜÈåØË™§:', error);
    
    if (event.replyToken && !tokenManager.isUsed(event.replyToken)) {
      await safeReply(event.replyToken, 'Êä±Ê≠âÔºåÊàëÈÅáÂà∞‰∫Ü‰∏Ä‰∫õÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶ÔΩû');
    }
  }
}

// ‰∏≠Èñì‰ª∂Ë®≠ÂÆö
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ÂïüÂãï‰º∫ÊúçÂô®
app.listen(PORT, '0.0.0.0', () => {
  console.log(`‚úÖ Â¢ûÂº∑Áâà LINE Bot ÊàêÂäüÂïüÂãïÔºÅ`);
  console.log(`üåê ‰º∫ÊúçÂô®ÈÅãË°åÂú®Á´ØÂè£ ${PORT}`);
  console.log(`‚ú® ÊâÄÊúâÂäüËÉΩÊ≠£Â∏∏ÈÅã‰Ωú`);
  console.log(`ü§ñ Á≥ªÁµ±Á©©ÂÆöÈÅãË°å‰∏≠`);
  
  setTimeout(async () => {
    try {
      const startupMessage = `üöÄ Â¢ûÂº∑Áâà v11.0 Â∑≤ÂïüÂãïÔºÅ

‚ú® Êñ∞Â¢ûÂäüËÉΩÔºö
‚Ä¢ Ê±∫Á≠ñÁ≥ªÁµ±Â¢ûÂº∑ÔºàÊèê‰æõ‰∏ä‰∏ãÊñáÔºâ
‚Ä¢ Á∂≤Ë∑ØÊêúÂ∞ãÂäüËÉΩ
‚Ä¢ Ë®äÊÅØËΩâÁôºÂäüËÉΩ
‚Ä¢ Â§öÁæ§ÁµÑÊ±∫Á≠ñËøΩËπ§
‚Ä¢ üìû Twilio Ë™ûÈü≥ÈÄöË©±ÊèêÈÜí (ÂØ¶È©óÊÄß)

‚úÖ ‰øÆÂæ©ÂäüËÉΩÔºö
‚Ä¢ Ê±∫Á≠ñÂõûË¶ÜÂäüËÉΩ
‚Ä¢ ÊèêÈÜíÁ≥ªÁµ±
‚Ä¢ ÈõªÂΩ±Êü•Ë©¢

üí° Ëº∏ÂÖ• /help Êü•Áúã‰∏ª‰∫∫Â∞àÁî®Êåá‰ª§

Á≥ªÁµ±ÁèæÂú®ÂäüËÉΩÂÆåÊï¥ÔºåÈö®ÊôÇÁÇ∫‰Ω†ÊúçÂãôÔºÅüòä`;

      await safePushMessage(OWNER_LINE_ID, startupMessage);
      console.log('ÂïüÂãïÈÄöÁü•Â∑≤ÁôºÈÄÅ');
    } catch (error) {
      console.error('ÂïüÂãïÈÄöÁü•ÁôºÈÄÅÂ§±Êïó:', error);
    }
  }, 3000);
});

module.exports = app;